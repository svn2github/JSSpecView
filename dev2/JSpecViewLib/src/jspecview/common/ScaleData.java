package jspecview.common;

/**
 * Stores information
 * about scale and range that <code>JSVPanel</code> needs to to display a
 * graph with a single plot. (For graphs that require multiple plots to be
 * overlayed. An instance of
 * {@link jspecview.common.MultiScaleData} may be generated by
 * {@link jspecview.common.MultiScaleData#generateScaleData(jspecview.common.Coordinate[][], int[], int[], int, int)}
 * You do not need to create an instance of this class manually. Instead call
 * the
 * {@link jspecview.common.Coordinate#generateScaleData(jspecview.common.Coordinate[], int, int, int, int)}
 * .
 */
public class ScaleData {
  // X variables
  /**
   * The minimum X value in the list of coordinates of the graph
   */
  public double minX;

  /**
   * The maximum X value in the list of coordinates of the graph
   */
  public double maxX;

  /**
   * The preferred number of X division for the scale
   */
  protected int numInitXdiv;

  /**
   * The precision (number of decimal places) of the Y values
   */
  public int hashNumX;

  /**
   * The step value of X axis of the scale
   */
  public double xStep;

  /**
   * the minimum X value on the scale
   */
  public double minXOnScale;

  /**
   * the maximim X value on the scale
   */
  public double maxXOnScale;

  /**
   * The actual number of divisons used for X axis
   */
  public int numOfXDivisions;

  // Y variables
  /**
   * The minimum Y value in the list of coordinates of the graph
   */
  public double minY;

  /**
   * The maximum Y value in the list of coordinates of the graph
   */
  public double maxY;

  /**
   * The preferred number of Y division for the scale
   */
  public int numInitYdiv;

  /**
   * The precision (number of decimal places) of the Y values
   */
  public int hashNumY;

  /**
   * The step value of Y axis of the scale
   */
  public double yStep;

  /**
   * the minimum Y value on the scale
   */
  public double minYOnScale;

  /**
   * the maximim Y value on the scale
   */
  public double maxYOnScale;

  /**
   * The actual number of divisons used X axis
   */
  public int numOfYDivisions;

  // Other
  /**
   * The start index
   */
  public int startDataPointIndex;

  /**
   * the end index
   */
  public int endDataPointIndex;

  /**
   * The number of points
   */
  public int numOfPoints;

  /**
   * Initialises a <code>ScaleData</code>
   */
  public ScaleData() {
  }

  /**
   * Initialises a <code>ScaleData</code> from another one
   * 
   * @param data
   *        the <code>ScaleData</code> to copy
   */
  public ScaleData(ScaleData data) {
    minX = data.minX;
    maxX = data.maxX;
    numInitXdiv = data.numInitXdiv;

    hashNumX = data.hashNumX;
    xStep = data.xStep;
    minXOnScale = data.minXOnScale;
    maxXOnScale = data.maxXOnScale;
    numOfXDivisions = data.numOfXDivisions;

    minY = data.minY;
    maxY = data.maxY;
    numInitYdiv = data.numInitYdiv;

    hashNumY = data.hashNumY;
    yStep = data.yStep;
    minYOnScale = data.minYOnScale;
    maxYOnScale = data.maxYOnScale;
    numOfYDivisions = data.numOfYDivisions;

    startDataPointIndex = data.startDataPointIndex;
    endDataPointIndex = data.endDataPointIndex;
    numOfPoints = data.numOfPoints;
  }

  /**
   * Determines if the x coordinate is within the range of coordinates in the
   * coordinate list
   * 
   * @param x
   *        the x coodinate
   * @param scaleData TODO
   * @return true if within range
   */
  public static boolean isWithinRange(double x, ScaleData scaleData) {
    if (x >= scaleData.minX && x <= scaleData.maxX)
      return true;
    return false;
  }

  /**
   * 
   * @param spectra
   * @param scaleData
   * @param initX
   * @param finalX
   * @param minPoints
   * @param startIndices  to fill
   * @param endIndices    to fill
   * @return
   */
  public static boolean setDataPointIndices(Graph[] spectra,
                                            MultiScaleData scaleData,
                                            double initX,
                                            double finalX, int minPoints,
                                            int[] startIndices,
                                            int[] endIndices) {
    int ptCount = 0;
    int nSpectraOK = 0;
    int nSpectra = startIndices.length;
    int index = 0;
    for (int i = 0; i < nSpectra; i++) {
      Coordinate[] xyCoords = spectra[i].getXYCoords();
      int iStart = scaleData.startDataPointIndices[i];
      int iEnd = scaleData.endDataPointIndices[i];
      for (index = iStart; index <= iEnd; index++) {
        double x = xyCoords[index].getXVal();
        if (x >= initX) {
          startIndices[i] = index;
          break;
        }
      }

      // determine endDataPointIndex
      for (; index <= iEnd; index++) {
        double x = xyCoords[index].getXVal();
        ptCount++;
        if (x >= finalX) {
          break;
        }
      }

      if (ptCount >= minPoints) {
        nSpectraOK++;
      }
      ptCount = 0;
      endIndices[i] = index - 1;
    }

    return (nSpectraOK == nSpectra);
  }


}